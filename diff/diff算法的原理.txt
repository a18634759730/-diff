 
 diff算法

   *diff算法的作用
     计算出Virtual DOM中真正的变化的部分，只针对该部分进行原生DOM的操作而非从新渲染整个页面

   *传统的diff算法
     通过循环递归对节点进行依次对比，算法复杂度达到O(n^3) 

   *O(n^3)是时间复杂度

     react树对比是按照层级去对比的， 他会给树编号0,1,2,3,4.... 
   然后相同的编号进行比较。 所以复杂度是n
   
     n是树的节点数 比如 如果要展现1000个节点，得执行上亿次的比较
   即便是CPU快能执行30亿条命令也很难在一秒内计算出差异   

     传统的diff需要出了上面的比较之外，还需要跨级比较。
   他会将两个数的节点，两两比较，这就有n^2的复杂度了
   
     然后还需要编辑树，编辑的树可能发生在任何节点，需要对树进行再一次
   遍历操作，因此复杂度为n。加起来就是n^3了

   
  *React的diff算法

    1.什么是调和
     将Virtual DOM树转换成 actual DOM树的最少操作的过程称为 调和

    2.什么是 React diff算法？
     diff算法是调和的具体实现

  *diff策略

    1.DOM节点跨层级的操作特别少，所以可以忽略不计
    2.拥有相同类的两个组件将会发生成相似的树形结构，拥有不同类的组件将会生成不同的树形
    3.同一层级的一组子节点，他们可以通过id进行区分
    
  Diff算法在执行时三个维度，分别是：Tree diff ，Component Diff 和 Element Diff 执行按顺序依次执行，
  他们的差异仅仅是diff粒度不同 ，执行的先后顺序不同
  
  *tree diff

     1.Web UI中DOM节点跨层级的移动操作特别少，可以忽略不计。
     2.对树的每一层遍历，如果组件不存在则会直接销毁      

  *component diff
    
 1.拥有相同类的两个组件 生成不存在相似的树形结构，

     2.拥有不同类的两个组件 生成不同的树形结构。
     3.同一类型的组件，继续比较下去
     4.是否需要比较
     5.shouldComponentUpdate

  *element diff
     1.对于同一层级的一组子节点，通过唯一id区分

     2.紧接着上述同一类型的组件，继续比较下去，常见类型：列表 
       同一个列表由旧变新有三种行为，插入、移动和删除，它的比
       较策略是对于每一个列表指定key，先将所有列表遍历一遍,确
       定要新增和删除的，再确定需要移动的

     3.比较产出：
              INSERT_MAKEUP 
                插入节点：对全新节点执行节点插入操作
              MOVE_EXISTING
                移动节点：组件新集合中有组件旧集合中的类型
                且element可更新，即组件调用了receiveComponent，这时可以复用之前的dom，执行dom移动操作
              REMOVE_NODE
		删除节点：此时有两种情况：组件新集合中有组件旧集合中的类型，但对应的element不可更新、
	        旧组建不在新集合里面，这两种情况需要执行节点删除操作
     4.比较策略:
              使用uuid也就是key对列表组件的命名
              先全部遍历一遍，确定要删除和新增的
              确定要remove的
     5.建议：
           id不要设置为数组的index，因为会变动，即使元素并未发生变化

        
           
    不管是什么算法最后都需要对比两个节点的不同。有三种情况需要考虑

    一.节点之间的比较
     *节点，英语里面的Node 包括两种类型
       1.是React的组件
       2.是html的DOM
     *节点类型的不同
       1.如果是html DOM不同的话，直接使用新的替换旧的
       2.如果是组件类型的不同话也直接使用新的替换旧的
     *HTML DOM类型相同
       在React里面的样式并不是一个纯粹的字符串，而是一个对象，这样的话在样式发生改变的时候只需要改变替换变化以后的样式，
       修改完当前节点之后递归处理该节点的子节点。
     *组件类型相同
       组件类型相同的，使用React机制处理,一般是使用新的props替换掉旧的props,并在之后调用组件的componentWill/DidReceiveProps方法,
       之前的组件的render方法会被调用。节点的比较机制开始递归作用于这个它的子节点上
    
    二.两个列表之间的比较
          一列节点中的一个发生的改变后  React并没有什么好的方法来处理这个问题。
       循环新旧两个列表，并找出不同是React 唯一的处理方法。
          但是有一个可以把这个算法的复杂度降低的办法。那就是我们在生成一列节点的时候
       给每个节点添加一个key "这个key只需要在这一列节点中唯一，不需要全局唯一"

    三，取舍
          需要注意的是上面启发算法是基于两种假设:
          *类型相同的节点总是生成同样的树，而类型不同的节点也总是生成不同的树， 
          *可以为多次render都表现稳定的节点设置key

        上面的节点之间的比较算法基本就是基于这两个假设而实现也就是要提高React应用的React的效率，需要我们按照这两点来假设开发
        否则React回重获整个App
    
         